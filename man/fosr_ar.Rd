% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler.R
\name{fosr_ar}
\alias{fosr_ar}
\title{MCMC Sampling Algorithm for the Function-on-Scalars Regression Model with
Time Series Errors}
\usage{
fosr_ar(Y, tau, X = NULL, K = NULL, nsave = 1000, nburn = 1000,
  nskip = 3, mcmc_params = list("beta", "fk", "alpha"), X_Tp1 = NULL,
  use_obs_SV = FALSE, includeBasisInnovation = FALSE, computeDIC = TRUE)
}
\arguments{
\item{Y}{the \code{T x m} data observation matrix, where \code{T} is the number of time points and \code{m} is the number of observation points (\code{NA}s allowed)}

\item{tau}{the \code{m x d} matrix of coordinates of observation points}

\item{X}{the \code{T x p} matrix of predictors; if NULL, only include an intercept}

\item{K}{the number of factors; if NULL, use SVD-based proportion of variability explained}

\item{nsave}{number of MCMC iterations to record}

\item{nburn}{number of MCMC iterations to discard (burin-in)}

\item{nskip}{number of MCMC iterations to skip between saving iterations,
i.e., save every (nskip + 1)th draw}

\item{mcmc_params}{named list of parameters for which we store the MCMC output;
must be one or more of
\itemize{
\item "beta" (factors)
\item "fk" (loading curves)
\item "alpha" (regression coefficients)
\item "mu_k" (intercept term for factor k)
\item "ar_phi" (AR coefficients for each k under AR(1) model)
\item "sigma_et" (observation error SD)
\item "Yhat" (fitted values)
\item "Ypred" (posterior predictive values)
\item "Yfore" (one-step forecast; includes the estimate and the distribution)
}}

\item{X_Tp1}{the \code{p x 1} matrix of predictors at the forecasting time point \code{T + 1};
if \code{NULL}, set to an intercept}

\item{use_obs_SV}{logical; when TRUE, include a stochastic volatility model
for the observation error variance}

\item{includeBasisInnovation}{logical; when TRUE, include an iid basis coefficient term for residual correlation
(i.e., the idiosyncratic error term for a factor model on the full basis matrix)}

\item{computeDIC}{logical; if TRUE, compute the deviance information criterion \code{DIC}
and the effective number of parameters \code{p_d}}
}
\value{
A named list of the \code{nsave} MCMC samples for the parameters named in \code{mcmc_params}
}
\description{
Runs the MCMC for the function-on-scalars regression model based on
an reduced-rank expansion. Here we assume the factor regression has AR(1) errors.
}
\note{
If \code{Tm} is large, then storing all posterior samples for \code{Yhat} or \code{Ypred}, which are \code{nsave x T x m},  may be inefficient
}
\examples{
\dontrun{
# Simulate some data:
sim_data = simulate_dfosr(T = 100, m = 20, p_0 = 2, p_1 = 2, use_dynamic_reg = FALSE)
Y = sim_data$Y; X = sim_data$X; tau = sim_data$tau
T = nrow(Y); m = ncol(Y); p = ncol(X) # Dimensions

# Run the MCMC w/ K = 6:
out = fosr_ar(Y = Y, tau = tau, X = X, K = 6,
              mcmc_params = list("beta", "fk", "alpha", "ar_phi", "Yhat", "Ypred"))

# Plot a regression coefficient function (Note: these are non-dynamic)
j = 3 # choose a predictor
post_alpha_tilde_j = get_post_alpha_tilde(out$fk, out$alpha[,1,j,])
plot_curve(post_f = post_alpha_tilde_j,
           tau = tau,
           main = paste('Posterior Mean and Credible bands, j =',j))
# Add the true regression coefficient function:
lines(tau, sim_data$alpha_tilde_true[1,j,], lwd=8, col='black', lty=6)

# Evidence for autocorrelation via the AR(1) coefficients:
plot(as.ts(out$ar_phi))
apply(out$ar_phi, 2, quantile, c(0.05/2, 1 - 0.05/2)) # 95\% credible intervals

# Plot the factors:
plot_factors(post_beta = out$beta)

# Plot the loading curves:
plot_flc(post_fk = out$fk, tau = tau)

# Plot a fitted value w/ posterior predictive credible intervals:
i = sample(1:T, 1); # Select a random time i
plot_fitted(y = Y[i,],
            mu = colMeans(out$Yhat)[i,],
            postY = out$Ypred[,i,],
            y_true = sim_data$Y_true[i,],
            t01 = tau)


}

}
