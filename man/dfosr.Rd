% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler.R
\name{dfosr}
\alias{dfosr}
\title{MCMC Sampling Algorithm for the Dynamic Function-on-Scalars Regression Model}
\usage{
dfosr(Y, tau, X = NULL, K = NULL, factor_model = "AR",
  use_dynamic_reg = TRUE, nsave = 1000, nburn = 1000, nskip = 3,
  mcmc_params = list("beta", "fk", "alpha", "mu_k", "ar_phi"),
  X_Tp1 = 1, use_obs_SV = FALSE, includeBasisInnovation = FALSE,
  computeDIC = TRUE)
}
\arguments{
\item{Y}{the \code{T x m} data observation matrix, where \code{T} is the number of time points and \code{m} is the number of observation points (\code{NA}s allowed)}

\item{tau}{the \code{m x d} matrix of coordinates of observation points}

\item{X}{the \code{T x p} matrix of predictors; if NULL, only include an intercept}

\item{K}{the number of factors; if NULL, use SVD-based proportion of variability explained}

\item{factor_model}{model for the factor-level (regression) errors;
must be one of
\itemize{
\item "IND" (independent errors)
\item "AR" (stationary autoregression of order 1)
\item "RW" (random walk model)
}}

\item{use_dynamic_reg}{logical; if TRUE, regression coefficients are dynamic
(with random walk models), otherwise independent}

\item{nsave}{number of MCMC iterations to record}

\item{nburn}{number of MCMC iterations to discard (burin-in)}

\item{nskip}{number of MCMC iterations to skip between saving iterations,
i.e., save every (nskip + 1)th draw}

\item{mcmc_params}{named list of parameters for which we store the MCMC output;
must be one or more of
\itemize{
\item "beta" (dynamic factors)
\item "fk" (loading curves)
\item "alpha" (regression coefficients; possibly dynamic)
\item "mu_k" (intercept term for factor k)
\item "ar_phi" (AR coefficients for each k under AR(1) model)
\item "sigma_et" (observation error SD; possibly dynamic)
\item "Yhat" (fitted values)
\item "Ypred" (posterior predictive values)
\item "Yfore" (one-step forecast; includes the estimate and the distribution)
}}

\item{X_Tp1}{the \code{p x 1} matrix of predictors at the forecasting time point \code{T + 1}}

\item{use_obs_SV}{logical; when TRUE, include a stochastic volatility model
for the observation error variance}

\item{includeBasisInnovation}{logical; when TRUE, include an iid basis coefficient term for residual correlation
(i.e., the idiosyncratic error term for a factor model on the full basis matrix)}

\item{computeDIC}{logical; if TRUE, compute the deviance information criterion \code{DIC}
and the effective number of parameters \code{p_d}}
}
\value{
A named list of the \code{nsave} MCMC samples for the parameters named in \code{mcmc_params}
}
\description{
Runs the MCMC for the dynamic function-on-scalars regression model based on
an reduced-rank expansion. We include several options for dynamics in the model,
including autoregressive, random walk, or independent errors, as well as
dynamic or non-dynamic regression coefficients. Default shrinkage priors are assumed.
}
\note{
This sampler loops over the k=1,...,K factors,
so the sampler is O(T*K*p^3) instead of O(T*(K*p)^3).
}
\examples{
\dontrun{
# Simulate some data:
sim_data = simulate_dfosr(T = 200, m = 50, p_0 = 2, p_1 = 2)
Y = sim_data$Y; X = sim_data$X; tau = sim_data$tau
T = nrow(Y); m = ncol(Y); p = ncol(X) # Dimensions

# Run the MCMC w/ K = 6:
out = dfosr(Y = Y, tau = tau, X = X, K = 6,
           factor_model = 'AR',
           use_dynamic_reg = TRUE,
           mcmc_params = list("beta", "fk", "alpha", "Yhat", "Ypred"))

# Plot a dynamic regression coefficient function
j = 3 # choose a predictor
post_alpha_tilde_j = get_post_alpha_tilde(out$fk, out$alpha[,,j,])

# Posterior mean:
alpha_tilde_j_pm = colMeans(post_alpha_tilde_j)

# Lower and Upper 95\% credible intervals:
alpha_tilde_j_lower = apply(post_alpha_tilde_j, 2:3, quantile, c(0.05/2))
alpha_tilde_j_upper = apply(post_alpha_tilde_j, 2:3, quantile, c(1 - 0.05/2))

# Plot lower pointwise interval:
filled.contour(1:T, tau, alpha_tilde_j_lower,
               zlim = range(alpha_tilde_j_lower, alpha_tilde_j_upper),
               color = terrain.colors,
               xlab = 'Time', ylab = expression(tau),
               main = paste('Lower 95\% Credible Intervals, j =',j))
# Plot posterior Mean:
filled.contour(1:T, tau, alpha_tilde_j_pm,
               zlim = range(alpha_tilde_j_lower, alpha_tilde_j_upper),
               color = terrain.colors,
               xlab = 'Time', ylab = expression(tau),
               main = paste('Posterior Mean, j =',j))
# Plot upper pointwise interval:
filled.contour(1:T, tau, sim_data$alpha_tilde_true[,j,],
               zlim = range(alpha_tilde_j_lower, alpha_tilde_j_upper),
               color = terrain.colors,
               xlab = 'Time', ylab = expression(tau),
               main = paste('Upper 95\% Credible Intervals, j =',j))
# Truth:
filled.contour(1:T, tau, alpha_tilde_j_upper,
               zlim = range(alpha_tilde_j_lower, alpha_tilde_j_upper),
               color = terrain.colors,
               xlab = 'Time', ylab = expression(tau),
               main = paste('True regression coefficients, j =',j))

# Verify by plotting at two time slices:
t1 = ceiling(0.2*T); # Time t1
plot_curve(post_f = post_alpha_tilde_j[,t1,],
           tau = tau,
           main = paste('Predictor j =',j,'at time t =',t1))
# Add the true regression coefficient function:
lines(tau, sim_data$alpha_tilde_true[t1,j,], lwd=8, col='black', lty=6)

t2 = ceiling(0.8*T) # Time t2
plot_curve(post_f = post_alpha_tilde_j[,t2,],
           tau = tau,
           main = paste('Predictor j =',j,'at time t =',t2))
# Add the true regression coefficient function:
lines(tau, sim_data$alpha_tilde_true[t2,j,], lwd=8, col='black', lty=6)

# Plot the factors:
plot_factors(post_beta = out$beta)

# Plot the loading curves:
plot_flc(post_fk = out$fk, tau = tau)

# Plot a fitted value w/ posterior predictive credible intervals:
i = sample(1:T, 1); # Select a random time i
plot_fitted(y = Y[i,],
            mu = colMeans(out$Yhat)[i,],
            postY = out$Ypred[,i,],
            y_true = sim_data$Y_true[i,],
            t01 = tau)
}
}
